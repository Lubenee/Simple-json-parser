<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Json Parser: Vector&lt; Type &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Json Parser
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Vector&lt; Type &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_vector_1_1_iterator.html" title="Iterator for the Vector class.">Iterator</a> for the <a class="el" href="class_vector.html">Vector</a> class.  <a href="class_vector_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad65912893a2e7ca590e39384540c2f43"><td class="memItemLeft" align="right" valign="top"><a id="ad65912893a2e7ca590e39384540c2f43" name="ad65912893a2e7ca590e39384540c2f43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> ()</td></tr>
<tr class="memdesc:ad65912893a2e7ca590e39384540c2f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_vector.html">Vector</a> object. <br /></td></tr>
<tr class="separator:ad65912893a2e7ca590e39384540c2f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42fb9899a8f86b96b000b4ad863d16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#aea42fb9899a8f86b96b000b4ad863d16">Vector</a> (std::initializer_list&lt; Type &gt; lst)</td></tr>
<tr class="memdesc:aea42fb9899a8f86b96b000b4ad863d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_vector.html">Vector</a> object with an initializer list.  <br /></td></tr>
<tr class="separator:aea42fb9899a8f86b96b000b4ad863d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb72fea13cfa171ff28d40df43711ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#afbb72fea13cfa171ff28d40df43711ec">Vector</a> (const int _size)</td></tr>
<tr class="memdesc:afbb72fea13cfa171ff28d40df43711ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_vector.html">Vector</a> object and reserve a given ammount of space.  <br /></td></tr>
<tr class="separator:afbb72fea13cfa171ff28d40df43711ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0561b2a0661c55d388f2ca73d9aa5e8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a0561b2a0661c55d388f2ca73d9aa5e8f">Vector</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp;other)</td></tr>
<tr class="memdesc:a0561b2a0661c55d388f2ca73d9aa5e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="class_vector.html">Vector</a> object Copy constructor. It requires that the objects have a defined operator=.  <br /></td></tr>
<tr class="separator:a0561b2a0661c55d388f2ca73d9aa5e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacec8379fd4e11d0487c365b530447e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#aacec8379fd4e11d0487c365b530447e7">push_back</a> (const Type &amp;new_data)</td></tr>
<tr class="memdesc:aacec8379fd4e11d0487c365b530447e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a new item to the back of the array.  <br /></td></tr>
<tr class="separator:aacec8379fd4e11d0487c365b530447e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b69499662bf8677d7ed4ec7c580f571"><td class="memItemLeft" align="right" valign="top"><a id="a7b69499662bf8677d7ed4ec7c580f571" name="a7b69499662bf8677d7ed4ec7c580f571"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>pop_back</b> ()</td></tr>
<tr class="memdesc:a7b69499662bf8677d7ed4ec7c580f571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element from the array. It's the user's responsibility to free any memory, if the object requires it. <br /></td></tr>
<tr class="separator:a7b69499662bf8677d7ed4ec7c580f571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadf73b37b504266f090943526825571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#adadf73b37b504266f090943526825571">begin</a> ()</td></tr>
<tr class="memdesc:adadf73b37b504266f090943526825571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the start of the vector.  <br /></td></tr>
<tr class="separator:adadf73b37b504266f090943526825571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fcb7e17a79f018013f5910cbcddd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#aa7fcb7e17a79f018013f5910cbcddd94">end</a> ()</td></tr>
<tr class="memdesc:aa7fcb7e17a79f018013f5910cbcddd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the vector.  <br /></td></tr>
<tr class="separator:aa7fcb7e17a79f018013f5910cbcddd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfd23b9758889cb885582dfe2485945"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_vector_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#acdfd23b9758889cb885582dfe2485945">cbegin</a> () const</td></tr>
<tr class="memdesc:acdfd23b9758889cb885582dfe2485945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the start of the vector.  <br /></td></tr>
<tr class="separator:acdfd23b9758889cb885582dfe2485945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f5c25bab399d53d45533fcc4b58305"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_vector_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#ab0f5c25bab399d53d45533fcc4b58305">cend</a> () const</td></tr>
<tr class="memdesc:ab0f5c25bab399d53d45533fcc4b58305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the vector.  <br /></td></tr>
<tr class="separator:ab0f5c25bab399d53d45533fcc4b58305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f1e234500da5f6a4e9170c5d959080"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a10f1e234500da5f6a4e9170c5d959080">size</a> () const</td></tr>
<tr class="memdesc:a10f1e234500da5f6a4e9170c5d959080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector's size.  <br /></td></tr>
<tr class="separator:a10f1e234500da5f6a4e9170c5d959080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b2896b25b8c133ecb88b517feff04f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a94b2896b25b8c133ecb88b517feff04f">capacity</a> () const</td></tr>
<tr class="memdesc:a94b2896b25b8c133ecb88b517feff04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector's capacity.  <br /></td></tr>
<tr class="separator:a94b2896b25b8c133ecb88b517feff04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323a883ca38db45a0d8ccf2e38b2f197"><td class="memItemLeft" align="right" valign="top"><a id="a323a883ca38db45a0d8ccf2e38b2f197" name="a323a883ca38db45a0d8ccf2e38b2f197"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="memdesc:a323a883ca38db45a0d8ccf2e38b2f197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector is empty. <br /></td></tr>
<tr class="separator:a323a883ca38db45a0d8ccf2e38b2f197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13993a7f5bda9aceb0bb3802c616e2d2"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a13993a7f5bda9aceb0bb3802c616e2d2">back</a> () const</td></tr>
<tr class="memdesc:a13993a7f5bda9aceb0bb3802c616e2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vector's last element.  <br /></td></tr>
<tr class="separator:a13993a7f5bda9aceb0bb3802c616e2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e9755be26fbbc8293814932e35eaeb"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#af1e9755be26fbbc8293814932e35eaeb">front</a> () const</td></tr>
<tr class="memdesc:af1e9755be26fbbc8293814932e35eaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vector's first element.  <br /></td></tr>
<tr class="separator:af1e9755be26fbbc8293814932e35eaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e6eee5487182ef9d966731f817b95d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a20e6eee5487182ef9d966731f817b95d">contains</a> (const Type &amp;elem) const</td></tr>
<tr class="memdesc:a20e6eee5487182ef9d966731f817b95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector contains the passed element.  <br /></td></tr>
<tr class="separator:a20e6eee5487182ef9d966731f817b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08a35e73fa5529217f9f4f099cdfaa0"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#ac08a35e73fa5529217f9f4f099cdfaa0">at</a> (const Type &amp;elem) const</td></tr>
<tr class="memdesc:ac08a35e73fa5529217f9f4f099cdfaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the passed element, if one is in the vector. This method requires that the objects have a valid operator==. If such an element isn't found, the method throws invalid_argument.  <br /></td></tr>
<tr class="separator:ac08a35e73fa5529217f9f4f099cdfaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d56e9122731b5bd4f60204bb23b0495"><td class="memItemLeft" align="right" valign="top"><a id="a6d56e9122731b5bd4f60204bb23b0495" name="a6d56e9122731b5bd4f60204bb23b0495"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a6d56e9122731b5bd4f60204bb23b0495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all elements. If any memory is allocated by the user, it's also the user's responsibility to free it manually. <br /></td></tr>
<tr class="separator:a6d56e9122731b5bd4f60204bb23b0495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65349f68ea78ca3c9c1a456678c97216"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a65349f68ea78ca3c9c1a456678c97216">reserve</a> (const size_t new_capacity)</td></tr>
<tr class="memdesc:a65349f68ea78ca3c9c1a456678c97216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory to accommodate a specified capacity for the <a class="el" href="class_vector.html">Vector</a>.  <br /></td></tr>
<tr class="separator:a65349f68ea78ca3c9c1a456678c97216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ad4a9545ae4d4b59d99b23c4458bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a48ad4a9545ae4d4b59d99b23c4458bb9">erase</a> (const size_t index)</td></tr>
<tr class="memdesc:a48ad4a9545ae4d4b59d99b23c4458bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element at <em>index</em>. The method does not handle errors if the index is out of range.  <br /></td></tr>
<tr class="separator:a48ad4a9545ae4d4b59d99b23c4458bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c08e85f59cd73cb9dd26c47dc0f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#ad46c08e85f59cd73cb9dd26c47dc0f9d">erase</a> (const Type &amp;elem)</td></tr>
<tr class="memdesc:ad46c08e85f59cd73cb9dd26c47dc0f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the passed element, if one is in the data array. Else throws invalid_argument.  <br /></td></tr>
<tr class="separator:ad46c08e85f59cd73cb9dd26c47dc0f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b9ed6848e51e99af7066d2ca69e6e4"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a20b9ed6848e51e99af7066d2ca69e6e4">operator[]</a> (const size_t index)</td></tr>
<tr class="memdesc:a20b9ed6848e51e99af7066d2ca69e6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at <em>index</em>. The method does not handle errors if the index is out of range.  <br /></td></tr>
<tr class="separator:a20b9ed6848e51e99af7066d2ca69e6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb37f73f19d43c66e80e09756026169b"><td class="memItemLeft" align="right" valign="top">const Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#acb37f73f19d43c66e80e09756026169b">operator[]</a> (const size_t index) const</td></tr>
<tr class="memdesc:acb37f73f19d43c66e80e09756026169b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the element at <em>index</em>. The method does not handle errors if the index is out of range.  <br /></td></tr>
<tr class="separator:acb37f73f19d43c66e80e09756026169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0934c668f58c5e0111cd2f419b2e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_vector.html#a00c0934c668f58c5e0111cd2f419b2e2">operator=</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp;other)</td></tr>
<tr class="memdesc:a00c0934c668f58c5e0111cd2f419b2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another <a class="el" href="class_vector.html">Vector</a> to this <a class="el" href="class_vector.html">Vector</a>.  <br /></td></tr>
<tr class="separator:a00c0934c668f58c5e0111cd2f419b2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea42fb9899a8f86b96b000b4ad863d16" name="aea42fb9899a8f86b96b000b4ad863d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea42fb9899a8f86b96b000b4ad863d16">&#9670;&#160;</a></span>Vector() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;<a class="el" href="class_vector.html">::Vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; Type &gt;&#160;</td>
          <td class="paramname"><em>lst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_vector.html">Vector</a> object with an initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lst</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbb72fea13cfa171ff28d40df43711ec" name="afbb72fea13cfa171ff28d40df43711ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb72fea13cfa171ff28d40df43711ec">&#9670;&#160;</a></span>Vector() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;<a class="el" href="class_vector.html">::Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_vector.html">Vector</a> object and reserve a given ammount of space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_size</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0561b2a0661c55d388f2ca73d9aa5e8f" name="a0561b2a0661c55d388f2ca73d9aa5e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0561b2a0661c55d388f2ca73d9aa5e8f">&#9670;&#160;</a></span>Vector() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;<a class="el" href="class_vector.html">::Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="class_vector.html">Vector</a> object Copy constructor. It requires that the objects have a defined operator=. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac08a35e73fa5529217f9f4f099cdfaa0" name="ac08a35e73fa5529217f9f4f099cdfaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08a35e73fa5529217f9f4f099cdfaa0">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::at </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the passed element, if one is in the vector. This method requires that the objects have a valid operator==. If such an element isn't found, the method throws invalid_argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type&amp; </dd></dl>

</div>
</div>
<a id="a13993a7f5bda9aceb0bb3802c616e2d2" name="a13993a7f5bda9aceb0bb3802c616e2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13993a7f5bda9aceb0bb3802c616e2d2">&#9670;&#160;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::back</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the vector's last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Type&amp; </dd></dl>

</div>
</div>
<a id="adadf73b37b504266f090943526825571" name="adadf73b37b504266f090943526825571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adadf73b37b504266f090943526825571">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::Iterator <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the start of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector_1_1_iterator.html" title="Iterator for the Vector class.">Iterator</a> </dd></dl>

</div>
</div>
<a id="a94b2896b25b8c133ecb88b517feff04f" name="a94b2896b25b8c133ecb88b517feff04f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b2896b25b8c133ecb88b517feff04f">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector's capacity. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="acdfd23b9758889cb885582dfe2485945" name="acdfd23b9758889cb885582dfe2485945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdfd23b9758889cb885582dfe2485945">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::Iterator <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::cbegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the start of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector_1_1_iterator.html" title="Iterator for the Vector class.">Iterator</a> </dd></dl>

</div>
</div>
<a id="ab0f5c25bab399d53d45533fcc4b58305" name="ab0f5c25bab399d53d45533fcc4b58305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f5c25bab399d53d45533fcc4b58305">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::Iterator <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::cend</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector_1_1_iterator.html" title="Iterator for the Vector class.">Iterator</a> </dd></dl>

</div>
</div>
<a id="a20e6eee5487182ef9d966731f817b95d" name="a20e6eee5487182ef9d966731f817b95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e6eee5487182ef9d966731f817b95d">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the vector contains the passed element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7fcb7e17a79f018013f5910cbcddd94" name="aa7fcb7e17a79f018013f5910cbcddd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fcb7e17a79f018013f5910cbcddd94">&#9670;&#160;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::Iterator <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_vector_1_1_iterator.html" title="Iterator for the Vector class.">Iterator</a> </dd></dl>

</div>
</div>
<a id="a48ad4a9545ae4d4b59d99b23c4458bb9" name="a48ad4a9545ae4d4b59d99b23c4458bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ad4a9545ae4d4b59d99b23c4458bb9">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element at <em>index</em>. The method does not handle errors if the index is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad46c08e85f59cd73cb9dd26c47dc0f9d" name="ad46c08e85f59cd73cb9dd26c47dc0f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c08e85f59cd73cb9dd26c47dc0f9d">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>elem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the passed element, if one is in the data array. Else throws invalid_argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1e9755be26fbbc8293814932e35eaeb" name="af1e9755be26fbbc8293814932e35eaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e9755be26fbbc8293814932e35eaeb">&#9670;&#160;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::front</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the vector's first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Type&amp; </dd></dl>

</div>
</div>
<a id="a00c0934c668f58c5e0111cd2f419b2e2" name="a00c0934c668f58c5e0111cd2f419b2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0934c668f58c5e0111cd2f419b2e2">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the contents of another <a class="el" href="class_vector.html">Vector</a> to this <a class="el" href="class_vector.html">Vector</a>. </p>
<p>This operator assigns the elements of the specified <a class="el" href="class_vector.html">Vector</a> to the current <a class="el" href="class_vector.html">Vector</a>, replacing its current contents. The size and capacity of this <a class="el" href="class_vector.html">Vector</a> may change to match the size of the assigned <a class="el" href="class_vector.html">Vector</a>. The assignment operator performs a deep copy of the elements, so each element is individually copied to the destination <a class="el" href="class_vector.html">Vector</a>. This requires that the elements in have a defined operator=.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="class_vector.html">Vector</a> whose elements are to be assigned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified <a class="el" href="class_vector.html">Vector</a> after the assignment.</dd></dl>
<p>NOTE: The assignment operator ensures that the current <a class="el" href="class_vector.html">Vector</a> is self-assignment safe. That is, assigning a <a class="el" href="class_vector.html">Vector</a> to itself has no effect and does not result in undefined behavior. </p>

</div>
</div>
<a id="a20b9ed6848e51e99af7066d2ca69e6e4" name="a20b9ed6848e51e99af7066d2ca69e6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b9ed6848e51e99af7066d2ca69e6e4">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the element at <em>index</em>. The method does not handle errors if the index is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type&amp; </dd></dl>

</div>
</div>
<a id="acb37f73f19d43c66e80e09756026169b" name="acb37f73f19d43c66e80e09756026169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb37f73f19d43c66e80e09756026169b">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Type &amp; <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const reference to the element at <em>index</em>. The method does not handle errors if the index is out of range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Type&amp; </dd></dl>

</div>
</div>
<a id="aacec8379fd4e11d0487c365b530447e7" name="aacec8379fd4e11d0487c365b530447e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacec8379fd4e11d0487c365b530447e7">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>new_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a new item to the back of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_data</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65349f68ea78ca3c9c1a456678c97216" name="a65349f68ea78ca3c9c1a456678c97216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65349f68ea78ca3c9c1a456678c97216">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves memory to accommodate a specified capacity for the <a class="el" href="class_vector.html">Vector</a>. </p>
<p>This method ensures that the <a class="el" href="class_vector.html">Vector</a> has enough memory allocated to hold at least the specified number of elements. If the requested capacity is less than or equal to the current capacity, this method has no effect. Otherwise, it allocates additional memory to accommodate the requested capacity, potentially increasing the <a class="el" href="class_vector.html">Vector</a>'s capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>The desired capacity for the <a class="el" href="class_vector.html">Vector</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE: This method does not modify the <a class="el" href="class_vector.html">Vector</a>'s size or change the actual number of elements stored in it. To add elements to the <a class="el" href="class_vector.html">Vector</a>, use the <code>push_back</code> method after reserving sufficient capacity. </p>

</div>
</div>
<a id="a10f1e234500da5f6a4e9170c5d959080" name="a10f1e234500da5f6a4e9170c5d959080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f1e234500da5f6a4e9170c5d959080">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_vector.html">Vector</a>&lt; Type &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector's size. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Libraries/<a class="el" href="_vector_8hpp_source.html">Vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
